- Class: meta
  Course: R Programming
  Lesson: Vectors
  Author: Nick Carchedi
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.0

- Class: text
  Output: Галю, найпростіша і найпоширеніша структура даних (data structure) в R - це vector (вектор).

- Class: text
  Output: 'Вектори бувають двох різних типів: atomic vectors (атомарні вектори) і lists (списки). Атомарний вектор містить точно один тип даних, тоді як список може містити кілька типів даних. Ми дослідимо атомарні вектори, перш ніж перейти до списків.'

- Class: text
  Output: У попередніх уроках ми мали справу виключно з numeric vectors (числовими векторами), які є одним типом атомарних векторів. Інші типи атомарних векторів включають logical (логічні), character (символьні), integer (цілі числа) та complex (комплексні). У цьому уроці ми детальніше розглянемо логічні та символьні вектори.

- Class: text
  Output: Логічні вектори можуть містити значення TRUE, FALSE та NA (для 'not available' - недоступно). Ці значення генеруються як результат логічних 'умов' (conditions). Давай поекспериментуємо з деякими простими умовами.

- Class: cmd_question
  Output: Спочатку створи числовий вектор num_vect, який містить значення 0.5, 55, -10 та 6.
  CorrectAnswer: num_vect <- c(0.5, 55, -10, 6)
  AnswerTests: omnitest(correctExpr='num_vect <- c(0.5, 55, -10, 6)')
  Hint: Пам'ятай, що функція c() використовується для створення вектора. Якщо забула, як її використовувати, скористайся ?c для доступу до файлу довідки. Не забудь присвоїти результат новій змінній під назвою num_vect.

- Class: cmd_question
  Output: Тепер створи змінну tf, яка отримає результат num_vect < 1, що читається як 'num_vect менше за 1'.
  CorrectAnswer: tf <- num_vect < 1
  AnswerTests: omnitest(correctExpr='tf <- num_vect < 1')
  Hint: Використай tf <- num_vect < 1, щоб присвоїти результат num_vect < 1 змінній під назвою tf.

- Class: mult_question
  Output: Як ти думаєш, як буде виглядати tf?
  CorrectAnswer: вектор з 4 логічних значень
  AnswerChoices: вектор з 4 логічних значень; одне логічне значення
  AnswerTests: omnitest(correctVal='вектор з 4 логічних значень')
  Hint: Пам'ятаєш наш урок про векторну арифметику? Основна ідея полягала в тому, що R виконує багато операцій поелементно (element-by-element). Ми називали такі операції 'векторизованими' (vectorized).

- Class: cmd_question
  Output: Виведи вміст tf зараз.
  CorrectAnswer: tf
  AnswerTests: omnitest(correctExpr='tf')
  Hint: Просто набери tf і натисни Enter, щоб переглянути її значення.

- Class: text
  Output: Вираз num_vect < 1 є умовою, і tf показує нам, чи кожен відповідний елемент нашого числового вектора num_vect задовольняє цю умову.

- Class: text
  Output: Перший елемент num_vect дорівнює 0.5, що менше за 1, тому вираз 0.5 < 1 є TRUE. Другий елемент num_vect дорівнює 55, що більше за 1, тому вираз 55 < 1 є FALSE. Та сама логіка застосовується для третього і четвертого елементів.

- Class: cmd_question
  Output: Спробуємо ще один. Набери num_vect >= 6, не присвоюючи результат новій змінній.
  CorrectAnswer: num_vect >= 6
  AnswerTests: omnitest(correctExpr='num_vect >= 6')
  Hint: Не створюй нову змінну для цього. Ми просто хочемо побачити результат num_vect >= 6. Переконайся, що немає пробілу між символами `>` і `=`. Думай про них як про один символ, що означає 'більше або дорівнює'.

- Class: text
  Output: Цього разу ми запитуємо, чи кожен окремий елемент num_vect більший АБО дорівнює 6. Оскільки тільки 55 і 6 більші або дорівнюють 6, другий і четвертий елементи результату є TRUE, а перший і третій елементи є FALSE.

- Class: text
  Output: Символи `<` і `>=` у цих прикладах називаються 'логічними операторами' (logical operators). Інші логічні оператори включають `>`, `<=`, `==` для точної рівності та `!=` для нерівності.

- Class: text
  Output: Якщо ми маємо два логічні вирази, A і B, ми можемо запитати, чи принаймні один з них TRUE за допомогою A | B (логічне 'або', також відоме як 'об''єднання'), або чи обидва TRUE за допомогою A & B (логічне 'і', також відоме як 'перетин'). Нарешті, !A - це заперечення A і є TRUE, коли A є FALSE, і навпаки.

- Class: text
  Output: Добра ідея - приділити деякий час експериментам з різними комбінаціями цих логічних операторів, поки ти не почуваєшся комфортно з їх використанням. Ми зробимо кілька прикладів тут, щоб допомогти тобі розпочати.

- Class: text
  Output: Постарайся якнайкраще передбачити результат кожного з наступних виразів. Ти можеш використовувати олівець і папір, щоб їх опрацювати, якщо це допомагає. Якщо застрягнеш, просто вгадуй - у тебе є 50% шансів на правильну відповідь!

- Class: mult_question
  Output: (3 > 5) & (4 == 4)
  CorrectAnswer: 'FALSE'
  AnswerChoices: TRUE; FALSE
  AnswerTests: omnitest(correctVal='FALSE')
  Hint: Розбий цю проблему на 2 частини. `&` посередині означає, що ОБІ частини TRUE. Твоє завдання - з'ясувати, чи це точне твердження. Якщо так, вся умова TRUE. Якщо ні, то FALSE.

- Class: mult_question
  Output: (TRUE == TRUE) | (TRUE == FALSE)
  CorrectAnswer: 'TRUE'
  AnswerChoices: TRUE; FALSE
  AnswerTests: omnitest(correctVal='TRUE')
  Hint: Розбий цю проблему на 2 частини. `|` посередині означає, що ПРИНАЙМНІ ОДНА з частин TRUE. Твоє завдання - з'ясувати, чи це точне твердження. Якщо так, вся умова TRUE. Якщо ні, то FALSE.

- Class: mult_question
  Output: ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)
  CorrectAnswer: 'TRUE'
  AnswerChoices: TRUE; FALSE
  AnswerTests: omnitest(correctVal='TRUE')
  Hint: Це складне завдання. Пам'ятай, що символ `!` заперечує все, що йде після нього. Тут також діє 'порядок операцій'. Умови, що знаходяться в дужках, слід обчислювати першими. Потім працюй назовні.

- Class: text
  Output: Не хвилюйся, якщо ці завдання здалися тобі складними. Вони мають бути такими. Робота з логічними виразами в R потребує практики, але твої зусилля будуть винагороджені в майбутніх уроках (наприклад, підмножини та структури управління).

- Class: text
  Output: Символьні вектори (character vectors) також дуже поширені в R. Подвійні лапки використовуються для розрізнення символьних об'єктів, як у наступному прикладі.

- Class: cmd_question
  Output: 'Створи символьний вектор, який містить наступні слова: "My", "name", "is". Пам''ятай обгорнути кожне слово у власний набір подвійних лапок, щоб R знав, що це символьні рядки (character strings). Збережи вектор у змінній під назвою my_char.'
  CorrectAnswer: my_char <- c("My", "name", "is")
  AnswerTests: omnitest(correctExpr='my_char <- c("My", "name", "is")')
  Hint: Набери my_char <- c("My", "name", "is"), щоб створити нову змінну my_char, яка містить символьний вектор довжиною 3. Переконайся, що коми, які розділяють слова, знаходяться ПОЗА подвійними лапками, інакше R подумає, що коми є частиною слів.

- Class: cmd_question
  Output: Виведи вміст my_char, щоб побачити, як це виглядає.
  CorrectAnswer: my_char
  AnswerTests: omnitest(correctExpr='my_char')
  Hint: Набери my_char, щоб переглянути її вміст.

- Class: text
  Output: Зараз my_char - це символьний вектор довжиною 3. Скажімо, ми хочемо з'єднати елементи my_char разом в один безперервний символьний рядок (тобто символьний вектор довжиною 1). Ми можемо зробити це, використовуючи функцію paste().

- Class: cmd_question
  Output: Набери paste(my_char, collapse = " ") зараз. Переконайся, що є пробіл між подвійними лапками в аргументі `collapse`. Ти побачиш, чому, за секунду.
  CorrectAnswer: paste(my_char, collapse = " ")
  AnswerTests: omnitest(correctExpr='paste(my_char, collapse = " ")')
  Hint: Використай paste(my_char, collapse = " "), щоб згорнути слова у векторі так, щоб вони майже утворили речення. Між подвійними лапками в аргументі `collapse` має бути один пробіл, щоб були окремі пробіли, що розділяють слова.

- Class: text
  Output: Аргумент `collapse` функції paste() говорить R, що коли ми з'єднуємо елементи символьного вектора my_char, ми хочемо розділити їх одинарними пробілами.

- Class: text
  Output: Здається, нам чогось бракує... Ах, так! Твоє ім'я!

- Class: cmd_question
  Output: 'Щоб додати (або ''конкатенувати'') твоє ім''я до кінця my_char, використай функцію c() ось так: c(my_char, "your_name_here"). Помісти своє ім''я в подвійні лапки там, де я поставила "your_name_here". Спробуй зараз, зберігши результат у новій змінній під назвою my_name.'
  CorrectAnswer: my_name <- c(my_char, "Swirl")
  AnswerTests: var_is_a("character", "my_name"); expr_uses_func("c"); expr_creates_var("my_name");
    val_has_length(4)
  Hint: Додай своє ім'я до кінця вектора my_char, використовуючи функцію c(). Переконайся, що присвоюєш результат новій змінній під назвою my_name. Якщо твоє ім'я "Swirl", ти б набрала my_name <- c(my_char, "Swirl").

- Class: cmd_question
  Output: Подивись на вміст my_name.
  CorrectAnswer: my_name
  AnswerTests: omnitest(correctExpr='my_name')
  Hint: Набери my_name і натисни Enter, щоб переглянути її вміст.

- Class: cmd_question
  Output: Тепер використай функцію paste() ще раз, щоб з'єднати слова в my_name разом в один символьний рядок. Не забудь сказати collapse = " "!
  CorrectAnswer: paste(my_name, collapse = " ")
  AnswerTests: omnitest(correctExpr='paste(my_name, collapse = " ")')
  Hint: Використай paste(my_name, collapse = " "), щоб з'єднати всі чотири слова разом, розділені одинарними пробілами.

- Class: text
  Output: У цьому прикладі ми використали функцію paste(), щоб згорнути елементи одного символьного вектора. paste() також може використовуватися для з'єднання елементів кількох символьних векторів.

- Class: cmd_question
  Output: У найпростішому випадку ми можемо з'єднати два символьні вектори, кожен довжиною 1 (тобто з'єднати два слова). Спробуй paste("Hello", "world!", sep = " "), де аргумент `sep` говорить R, що ми хочемо розділити з'єднані елементи одинарним пробілом.
  CorrectAnswer: paste("Hello", "world!", sep = " ")
  AnswerTests: omnitest(correctExpr='paste("Hello", "world!", sep = " ")')
  Hint: Введи paste("Hello", "world!", sep = " "), щоб з'єднати два слова "Hello" і "world", розділені одинарним пробілом. Між подвійними лапками в аргументі `sep` функції paste() має бути один пробіл.

- Class: cmd_question
  Output: Для трохи складнішого прикладу ми можемо з'єднати два вектори, кожен довжиною 3. Використай paste(), щоб з'єднати цілочисельний вектор 1:3 з символьним вектором c("X", "Y", "Z"). Цього разу використай sep = "", щоб не залишати пробілу між з'єднаними елементами.
  CorrectAnswer: paste(1:3, c("X", "Y", "Z"), sep = "")
  AnswerTests: any_of_exprs('paste(1:3, c("X", "Y", "Z"), sep = "")', 'paste(c(1:3), c("X", "Y", "Z"), sep = "")')
  Hint: Використай paste(1:3, c("X", "Y", "Z"), sep = ""), щоб побачити, що станеться, коли ми з'єднуємо два вектори однакової довжини за допомогою paste().

- Class: text
  Output: 'Як ти думаєш, що станеться, якщо наші вектори мають різну довжину? (Підказка: ми говорили про це в попередньому уроці.)'

- Class: cmd_question
  Output: Переробка векторів (vector recycling)! Спробуй paste(LETTERS, 1:4, sep = "-"), де LETTERS - це заздалегідь визначена змінна в R, що містить символьний вектор з усіх 26 літер англійського алфавіту.
  CorrectAnswer: paste(LETTERS, 1:4, sep = "-")
  AnswerTests: omnitest(correctExpr='paste(LETTERS, 1:4, sep = "-")')
  Hint: Набери paste(LETTERS, 1:4, sep = "-"), щоб побачити, як R переробляє вектор 1:4, щоб відповідати довжині LETTERS. Зверни увагу, що цього разу ми використовуємо `-` як роздільник замість одинарного пробілу.

- Class: text
  Output: Оскільки символьний вектор LETTERS довший за числовий вектор 1:4, R просто переробляє або повторює 1:4, поки він не відповідає довжині LETTERS.

- Class: text
  Output: Також варто зазначити, що числовий вектор 1:4 'примушується' (coerced) до символьного вектора функцією paste().

- Class: text
  Output: Ми обговоримо примушування в іншому уроці, але все, що це дійсно означає, це те, що числа 1, 2, 3 і 4 у виході вище більше не є числами для R, а радше символами "1", "2", "3" і "4".

- Class: mult_question
  Output: Чи хотіла б ти повідомити комусь про успішне завершення цього уроку?
  CorrectAnswer: NULL
  AnswerChoices: Так; Ні
  AnswerTests: notify()
  Hint: NULL
