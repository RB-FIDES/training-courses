- Class: meta
  Course: R Programming_Alt
  Lesson: Simulation
  Author: Nick Carchedi - переклад (oleksandkov | AI)
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.11

- Class: text
  Output: Однією з великих переваг використання статистичної мови програмування, такої як R, є її величезна колекція інструментів для моделювання випадкових чисел.

- Class: text
  Output: Цей урок передбачає знайомство з кількома поширеними ймовірнісними розподілами, проте ці теми будуть розглядатися лише в контексті генерації випадкових чисел. Навіть якщо у вас немає попереднього досвіду з цими поняттями, ви зможете пройти цей урок і зрозуміти основні ідеї.

- Class: cmd_question
  Output: Першою функцією, яку ми використаємо для генерації випадкових чисел, буде sample(). Використайте ?sample, щоб відкрити документацію.
  CorrectAnswer: ?sample
  AnswerTests: omnitest(correctExpr='?sample')
  Hint: Використайте '?sample', щоб відкрити документацію для функції sample().

- Class: cmd_question
  Output: "Змоделюємо кидання чотирьох шестигранних кубиків: sample(1:6, 4, replace = TRUE)."
  CorrectAnswer: sample(1:6, 4, replace = TRUE)
  AnswerTests: match_call('sample(1:6, 4, replace = TRUE)')
  Hint: Введіть sample(1:6, 4, replace = TRUE), щоб змоделювати кидання чотирьох шестигранних кубиків.

- Class: cmd_question
  Output: Тепер повторіть цю команду, щоб побачити, наскільки відрізняється ваш результат. (Ймовірність отримати точно такий же результат становить (1/6)^4 = 0.00077, що досить мало!)
  CorrectAnswer: sample(1:6, 4, replace = TRUE)
  AnswerTests: match_call('sample(1:6, 4, replace = TRUE)')
  Hint: Введіть sample(1:6, 4, replace = TRUE), щоб ще раз змоделювати кидання чотирьох кубиків.

- Class: text
  Output: sample(1:6, 4, replace = TRUE) наказує R випадковим чином вибрати чотири числа від 1 до 6 З поверненням. Вибір з поверненням означає, що кожне число "повертається" після вибору, тому одне й те саме число може з'явитися кілька разів. Це саме те, що нам потрібно, адже кидок одного кубика не має впливати на інші.

- Class: cmd_question
  Output: Тепер виберіть 10 чисел від 1 до 20 БЕЗ повернення. Щоб вибрати без повернення, просто не вказуйте аргумент 'replace'.
  CorrectAnswer: sample(1:20, 10)
  AnswerTests: match_call('sample(1:20, 10)')
  Hint: Введіть sample(1:20, 10), щоб вибрати 10 чисел від 1 до 20 без повернення.

- Class: text
  Output: Оскільки попередня команда вибирала без повернення, жодне число не з'являється більше одного разу у результаті.

- Class: cmd_question
  Output: LETTERS — це попередньо визначена змінна в R, яка містить вектор з усіх 26 літер англійського алфавіту. Перегляньте її зараз.
  CorrectAnswer: LETTERS
  AnswerTests: omnitest(correctExpr='LETTERS')
  Hint: Введіть LETTERS, щоб вивести її зміст у консоль.

- Class: cmd_question
  Output: Функція sample() також може використовуватись для перестановки, або перемішування, елементів вектора. Наприклад, спробуйте sample(LETTERS), щоб перемішати всі 26 літер англійського алфавіту.
  CorrectAnswer: sample(LETTERS)
  AnswerTests: omnitest(correctExpr='sample(LETTERS)')
  Hint: Використайте sample(LETTERS), щоб перемішати всі 26 літер англійського алфавіту.

- Class: text
  Output: Це ідентично вибору вибірки розміром 26 з LETTERS без повернення. Якщо аргумент 'size' для sample() не вказано, R вибирає кількість елементів, що дорівнює розміру вектора, з якого ви вибираєте.

- Class: text
  Output: Тепер, припустимо, ми хочемо змоделювати 100 підкидів несправедливої двосторонньої монети. Ця конкретна монета має ймовірність 0.3 випадіння "решки" та 0.7 випадіння "герба".

- Class: cmd_question
  Output: Нехай значення 0 означає "решка", а 1 — "герб". Використайте sample(), щоб вибрати 100 значень з вектора c(0,1) з поверненням. Оскільки монета нечесна, потрібно задати ймовірності для 0 (решка) і 1 (герб) четвертим аргументом prob = c(0.3, 0.7). Запишіть результат у нову змінну під назвою flips.
  CorrectAnswer: flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7))
  AnswerTests: match_call('flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7))')
  Hint: 'Наступна команда змоделює 100 підкидів нечесної монети і збереже результат: flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7))'

- Class: cmd_question
  Output: Перегляньте вміст змінної flips.
  CorrectAnswer: flips
  AnswerTests: omnitest(correctExpr='flips')
  Hint: Просто введіть flips, щоб переглянути її вміст.

- Class: cmd_question
  Output: Оскільки ми задали ймовірність випадіння "герба" 0.7, очікуємо приблизно 70 одиниць у flips. Порахуйте фактичну кількість 1 у flips за допомогою функції sum().
  CorrectAnswer: sum(flips)
  AnswerTests: omnitest(correctExpr='sum(flips)')
  Hint: sum(flips) підсумує всі 1 і 0, тобто дасть кількість "гербів" у flips.

- Class: cmd_question
  Output: Підкидання монети — це бінарний результат (0 або 1), і ми виконуємо 100 незалежних підкидів, тому можемо скористатись rbinom() для моделювання біноміальної випадкової величини. Відкрийте документацію для rbinom за допомогою ?rbinom.
  CorrectAnswer: ?rbinom
  AnswerTests: omnitest(correctExpr='?rbinom')
  Hint: Введіть ?rbinom, щоб відкрити довідку по функції rbinom().

- Class: text
  Output: Для кожного ймовірнісного розподілу в R існує функція r*** (для "random"), d*** (для "density"), p*** (для "probability") та q*** (для "quantile"). У цьому уроці нас найбільше цікавлять r***-функції, але радимо дослідити й інші самостійно.

- Class: cmd_question
  Output: Біноміальна випадкова величина означає кількість "успіхів" (гербів) у заданій кількості незалежних "випробувань" (підкидів монети). Тому можна змоделювати одну випадкову величину, що відповідає кількості гербів у 100 підкидах нечесної монети, так: rbinom(1, size = 100, prob = 0.7). Зверніть увагу, що потрібно вказувати лише ймовірність "успіху" (герб), а не "невдачі" (решка). Спробуйте.
  CorrectAnswer: rbinom(1, size = 100, prob = 0.7)
  AnswerTests: match_call('rbinom(1, size = 100, prob = 0.7)')
  Hint: Викличте rbinom() з n = 1, size = 100 та prob = 0.7.

- Class: cmd_question
  Output: Аналогічно, якщо хочемо бачити всі 0 та 1, можна запросити 100 спостережень, кожне розміром 1, з імовірністю успіху 0.7. Зробіть це, зберігши результат у нову змінну flips2.
  CorrectAnswer: flips2 <- rbinom(100, size = 1, prob = 0.7)
  AnswerTests: match_call('flips2 <- rbinom(100, size = 1, prob = 0.7)')
  Hint: Викличте rbinom() з n = 100, size = 1, prob = 0.7 і збережіть результат у flips2.

- Class: cmd_question
  Output: Перегляньте вміст flips2.
  CorrectAnswer: flips2
  AnswerTests: omnitest('flips2')
  Hint: Введіть flips2, щоб переглянути її вміст.

- Class: cmd_question
  Output: Тепер використайте sum(), щоб порахувати кількість 1 (гербів) у flips2. Має бути близько 70!
  CorrectAnswer: sum(flips2)
  AnswerTests: omnitest('sum(flips2)')
  Hint: Використайте sum(flips2), щоб порахувати кількість 1.

- Class: cmd_question
  Output: Аналогічно rbinom(), R дозволяє моделювати випадкові числа з багатьох інших ймовірнісних розподілів. Відкрийте документацію для rnorm прямо зараз.
  CorrectAnswer: ?rnorm
  AnswerTests: omnitest('?rnorm')
  Hint: Введіть ?rnorm, щоб переглянути довідку по функції rnorm().

- Class: cmd_question
  Output: Стандартний нормальний розподіл має середнє 0 та стандартне відхилення 1. Як видно з розділу 'Usage' у документації, значення за замовчуванням для аргументів 'mean' і 'sd' у rnorm() — 0 і 1 відповідно. Тобто rnorm(10) згенерує 10 випадкових чисел із стандартного нормального розподілу. Спробуйте.
  CorrectAnswer: rnorm(10)
  AnswerTests: omnitest('rnorm(10)')
  Hint: Використайте rnorm(10), щоб згенерувати 10 випадкових чисел зі стандартного нормального розподілу.

- Class: cmd_question
  Output: Тепер зробіть те саме, але з середнім 100 та стандартним відхиленням 25.
  CorrectAnswer: rnorm(10, 100, 25)
  AnswerTests: match_call('rnorm(10, 100, 25)')
  Hint: Використайте rnorm(10, mean = 100, sd = 25), щоб згенерувати 10 випадкових чисел із нормального розподілу з середнім 100 та стандартним відхиленням 25.

- Class: text
  Output: Нарешті, що як нам потрібно змоделювати 100 *груп* випадкових чисел, кожна з яких містить 5 значень, отриманих із розподілу Пуассона із середнім 10? Давайте почнемо з однієї групи з 5 чисел, а потім я покажу, як зручно і компактно повторити цю операцію 100 разів.

- Class: cmd_question
  Output: Згенеруйте 5 випадкових значень із розподілу Пуассона з середнім 10. Перегляньте документацію для rpois(), якщо потрібно.
  CorrectAnswer: rpois(5, 10)
  AnswerTests: match_call('rpois(5, 10)')
  Hint: Використайте rpois(5, 10), щоб згенерувати 5 випадкових чисел із розподілу Пуассона із середнім 10.

- Class: cmd_question
  Output: Тепер використайте replicate(100, rpois(5, 10)), щоб виконати цю операцію 100 разів. Збережіть результат у нову змінну my_pois.
  CorrectAnswer: my_pois <- replicate(100, rpois(5, 10))
  AnswerTests: match_call('my_pois <- replicate(100, rpois(5, 10))')
  Hint: my_pois <- replicate(100, rpois(5, 10)) повторить операцію 100 разів і збереже результат.

- Class: cmd_question
  Output: Перегляньте вміст my_pois.
  CorrectAnswer: my_pois
  AnswerTests: omnitest('my_pois')
  Hint: Виведіть вміст my_pois у консоль.

- Class: cmd_question
  Output: replicate() створив матрицю, кожен стовпець якої містить 5 випадкових чисел, згенерованих із розподілу Пуассона із середнім 10. Тепер знайдемо середнє кожного стовпця в my_pois за допомогою функції colMeans(). Збережіть результат у змінній cm.
  CorrectAnswer: cm <- colMeans(my_pois)
  AnswerTests: omnitest('cm <- colMeans(my_pois)')
  Hint: Використайте cm <- colMeans(my_pois), щоб створити вектор середніх по стовпцях і зберегти його у cm.

- Class: cmd_question
  Output: А тепер подивимось на розподіл наших середніх по стовпцях, побудувавши гістограму hist(cm).
  CorrectAnswer: hist(cm)
  AnswerTests: omnitest('hist(cm)')
  Hint: hist(cm) побудує гістограму середніх по стовпцях.

- Class: text
  Output: Схоже, що наші середні по стовпцях майже нормально розподілені, так? Це працює центральна гранична теорема, але це вже тема для іншого уроку!

- Class: text
  Output: Усі стандартні ймовірнісні розподіли вбудовано в R, зокрема експоненційний (rexp()), хі-квадрат (rchisq()), гамма (rgamma()), ... Ну, ви зрозуміли принцип.

- Class: text
  Output: Симуляція — це фактично окремий напрямок, і ми лише поверхнево торкнулися можливостей. Закликаю вас дослідити ці та інші функції самостійно.

- Class: mult_question
  Output: Бажаєте повідомити когось про успішне завершення цього уроку?
  CorrectAnswer: NULL
  AnswerChoices: Так; Ні
  AnswerTests: notify()
  Hint: NULL
