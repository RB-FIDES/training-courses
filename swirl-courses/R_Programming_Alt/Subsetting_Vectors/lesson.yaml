- Class: meta
  Course: R Programming_Alt
  Lesson: Subsetting Vectors
  Author: Nick Carchedi - переклад (oleksandkov | AI)
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.0

- Class: text
  Output: У цьому уроці ми навчимося витягати елементи з вектора на основі певних умов, які ми задаємо.

- Class: text
  Output: Наприклад, нас можуть цікавити лише перші 20 елементів вектора, або лише ті елементи, які не є NA, або лише ті, які додатні, або які відповідають певній змінній з інтересом. Після завершення цього уроку ти знатимеш, як діяти в кожній із цих ситуацій.

- Class: cmd_question
  Output: Я створила для тебе вектор x, який містить випадкове переставлення 20 чисел (зі стандартного нормального розподілу) і 20 NA. Надрукуй x, щоб побачити, як він виглядає.
  CorrectAnswer: x
  AnswerTests: omnitest(correctExpr='x')
  Hint: Надрукуй x, щоб подивитись його вміст.

- Class: text
  Output: Щоб повідомити R, що ти хочеш вибрати певні елементи (тобто "підмножину") з вектора, потрібно розмістити "індекс-вектор" у квадратних дужках одразу після імені вектора.

- Class: cmd_question
  Output: Для простого прикладу спробуй x[1:10], щоб переглянути перші десять елементів x.
  CorrectAnswer: x[1:10]
  AnswerTests: omnitest(correctExpr='x[1:10]')
  Hint: Переглянь перші десять елементів x за допомогою x[1:10].

- Class: text
  Output: Індекс-вектори бувають чотирьох типів — логічні вектори, вектори додатних цілих чисел, вектори від’ємних цілих чисел і вектори рядків-символів — кожен з яких ми розглянемо в цьому уроці.

- Class: text
  Output: Почнемо з індексування логічними векторами. Поширена ситуація в роботі з реальними даними — це коли ми хочемо витягти всі елементи вектора, які не є NA (тобто відсутні дані). Нагадаю, що is.na(x) повертає вектор логічних значень тієї ж довжини, що й x, де TRUE відповідає NA в x, а FALSE — не NA.

- Class: mult_question
  Output: Як ти думаєш, що поверне x[is.na(x)]?
  AnswerChoices: Вектор з усіх NA; Вектор без NA; Вектор з TRUE та FALSE; Вектор довжини 0
  CorrectAnswer: Вектор з усіх NA
  AnswerTests: omnitest(correctVal="Вектор з усіх NA")
  Hint: Пам'ятай, що is.na(x) показує, де є NA у векторі. Якщо ми вибираємо x за цим критерієм, що ти очікуєш побачити?

- Class: cmd_question
  Output: Переконайся самостійно, надрукувавши x[is.na(x)].
  CorrectAnswer: x[is.na(x)]
  AnswerTests: omnitest(correctExpr='x[is.na(x)]')
  Hint: Надрукуй x[is.na(x)] і побачиш, що отримаєш всі NA — це точно не те, чого ми хочемо!

- Class: cmd_question
  Output: Нагадаю, що `!` дає заперечення логічного виразу, тому !is.na(x) читається як "не NA". Тому, якщо ми хочемо створити вектор y, який містить усі не NA значення з x, можемо використати y <- x[!is.na(x)]. Спробуй це зробити.
  CorrectAnswer: y <- x[!is.na(x)]
  AnswerTests: omnitest(correctExpr='y <- x[!is.na(x)]')
  Hint: Введи y <- x[!is.na(x)], щоб отримати всі не пропущені значення x.

- Class: cmd_question
  Output: Виведи y у консоль.
  CorrectAnswer: 'y'
  AnswerTests: omnitest(correctExpr='y')
  Hint: Надрукуй y, щоб подивитися його вміст.

- Class: text
  Output: Тепер, коли ми виділили не пропущені значення x і помістили їх у y, можемо підмножувати y як завгодно.

- Class: mult_question
  Output: Нагадаю, що вираз y > 0 повертає вектор логічних значень тієї ж довжини, що й y, де TRUE відповідає додатним значенням y, а FALSE — нульовим або від’ємним. Як ти думаєш, що поверне y[y > 0]?
  AnswerChoices: Вектор з усіх додатних елементів y; Вектор з усіх від’ємних елементів y; Вектор з усіх NA; Вектор довжини 0; Вектор з TRUE та FALSE
  CorrectAnswer: Вектор з усіх додатних елементів y
  AnswerTests: omnitest(correctVal="Вектор з усіх додатних елементів y")
  Hint: Логічний вираз y > 0 дасть TRUE для кожного додатного елемента y. Що поверне y[y > 0]?

- Class: cmd_question
  Output: Введи y[y > 0], щоб побачити всі додатні елементи y, які також є додатними у початковому x.
  CorrectAnswer: y[y > 0]
  AnswerTests: omnitest(correctExpr='y[y > 0]')
  Hint: Надрукуй y[y > 0], щоб побачити тільки додатні елементи y.

- Class: cmd_question
  Output: Ти можеш запитати, чому ми відразу не використали x[x > 0], щоб виділити додатні елементи x. Спробуй це зараз і зрозумієш чому.
  CorrectAnswer: x[x > 0]
  AnswerTests: omnitest(correctExpr='x[x > 0]')
  Hint: Спробуй x[x > 0], щоб зрозуміти, чому ми не використали цей підхід.

- Class: text
  Output: Оскільки NA — це не значення, а позначка для невідомої величини, вираз NA > 0 повертає NA. Тому ми отримуємо багато NA разом з додатними числами, коли робимо це.

- Class: cmd_question
  Output: Поєднавши знання про логічні оператори й підмноження, можна так: x[!is.na(x) & x > 0]. Спробуй це.
  CorrectAnswer: x[!is.na(x) & x > 0]
  AnswerTests: omnitest(correctExpr='x[!is.na(x) & x > 0]')
  Hint: Введи x[!is.na(x) & x > 0], щоб побачити результат.

- Class: text
  Output: У цьому випадку ми просимо лише ті значення x, які одночасно не пропущені І більші за нуль.

- Class: text
  Output: Я вже показувала, як виділити лише перші десять значень x за допомогою x[1:10]. У цьому випадку ми передаємо вектор додатних цілих чисел у квадратних дужках, що каже R повернути елементи x з номерами від 1 до 10.

- Class: text
  Output: У багатьох мовах програмування використовується "нульова індексація", тобто перший елемент вектора вважається елементом 0. R використовує "одиничну індексацію", тобто перший елемент — це 1.

- Class: cmd_question
  Output: Чи можеш ти здогадатися, як виділити 3-й, 5-й і 7-й елементи x? Підказка — використай функцію c(), щоб задати номери елементів як числовий вектор.
  CorrectAnswer: x[c(3, 5, 7)]
  AnswerTests: omnitest(correctExpr='x[c(3, 5, 7)]')
  Hint: Створи вектор індексів c(3, 5, 7), а потім помісти його у квадратні дужки.

- Class: cmd_question
  Output: Важливо, що при використанні цілих чисел-індексів для підмноження x слід дотримуватися набору індексів {1, 2, ..., 40}, оскільки x має лише 40 елементів. Що буде, якщо ми попросимо нульовий елемент x (тобто x[0])? Спробуй це.
  CorrectAnswer: x[0]
  AnswerTests: omnitest(correctExpr='x[0]')
  Hint: Спробуй x[0], щоб побачити, що станеться при зверненні до нульового елемента вектора, який у R не визначено.

- Class: cmd_question
  Output: Як і очікувалось, нічого корисного ми не отримуємо. На жаль, R не заважає це робити. А якщо попросити 3000-й елемент x? Спробуй це.
  CorrectAnswer: x[3000]
  AnswerTests: omnitest(correctExpr='x[3000]')
  Hint: Запроси 3000-й елемент x (якого не існує) через x[3000].

- Class: text
  Output: Знову ж таки, нічого корисного, але R не запобігає цим діям. Це має бути для тебе попередженням: завжди стеж за тим, щоб твій запит був у межах вектора, з яким ти працюєш.

- Class: text
  Output: А якщо нам потрібні всі елементи x, КРІМ 2-го й 10-го? Було б досить обтяжливо будувати вектор з усіх чисел від 1 до 40, крім 2 та 10.

- Class: cmd_question
  Output: На щастя, R приймає від’ємні цілі індекси. Якщо x[c(2, 10)] дає нам ЛИШЕ 2-й і 10-й елементи x, то x[c(-2, -10)] дає всі елементи x, КРІМ 2-го та 10-го. Спробуй x[c(-2, -10)].
  CorrectAnswer: x[c(-2, -10)]
  AnswerTests: omnitest(correctExpr='x[c(-2, -10)]')
  Hint: Спробуй x[c(-2, -10)].

- Class: cmd_question
  Output: Скороченим способом задання кількох від’ємних чисел є винесення мінуса перед вектором індексів. Введи x[-c(2, 10)], щоб отримати той самий результат.
  CorrectAnswer: x[-c(2, 10)]
  AnswerTests: omnitest(correctExpr='x[-c(2, 10)]')
  Hint: Використай x[-c(2, 10)] для спрощення. Це корисно, якщо багато індексів.

- Class: text
  Output: Отже, ми розглянули три типи індекс-векторів: логічні, додатні цілі і від’ємні цілі числа. Залишився ще один — потрібно познайомитись із "іменованими" елементами.

- Class: cmd_question
  Output: Створи числовий вектор із трьома іменованими елементами за допомогою vect <- c(foo = 11, bar = 2, norf = NA).
  CorrectAnswer: vect <- c(foo = 11, bar = 2, norf = NA)
  AnswerTests: omnitest(correctExpr='vect <- c(foo = 11, bar = 2, norf = NA)')
  Hint: Створи іменований вектор vect <- c(foo = 11, bar = 2, norf = NA).

- Class: cmd_question
  Output: Коли ми надрукуємо vect у консолі, побачиш, що кожен елемент має ім'я. Спробуй це.
  CorrectAnswer: vect
  AnswerTests: omnitest(correctExpr='vect')
  Hint: Надрукуй vect, щоб побачити його вміст.

- Class: cmd_question
  Output: Ми можемо отримати імена vect через функцію names(vect). Спробуй це.
  CorrectAnswer: names(vect)
  AnswerTests: omnitest(correctExpr='names(vect)')
  Hint: Перевір результат names(vect).

- Class: cmd_question
  Output: Також можемо створити неіменований вектор vect2 через c(11, 2, NA). Зроби це.
  CorrectAnswer: vect2 <- c(11, 2, NA)
  AnswerTests: omnitest(correctExpr='vect2 <- c(11, 2, NA)')
  Hint: Створи звичайний (неіменований) вектор vect2 з c(11, 2, NA).

- Class: cmd_question
  Output: Потім можемо додати атрибут names до vect2 вже після створення: names(vect2) <- c("foo", "bar", "norf"). Зроби це.
  CorrectAnswer: names(vect2) <- c("foo", "bar", "norf")
  AnswerTests: omnitest(correctExpr='names(vect2) <- c("foo", "bar", "norf")')
  Hint: Додай імена до vect2 через names(vect2) <- c("foo", "bar", "norf").

- Class: cmd_question
  Output: Тепер перевіримо, чи vect і vect2 однакові, передавши їх у функцію identical().
  CorrectAnswer: identical(vect, vect2)
  AnswerTests: any_of_exprs('identical(vect, vect2)', 'identical(vect2, vect)')
  Hint: Функція identical() показує, чи її перші два аргументи — ідентичні.

- Class: text
  Output: Справді, vect і vect2 — це однакові іменовані вектори.

- Class: mult_question
  Output: Тепер повернімось до підмноження вектора за іменованими елементами. Яка з наступних команд, на твою думку, поверне другий елемент vect?
  AnswerChoices: vect["bar"]; vect[bar]; vect["2"]
  CorrectAnswer: vect["bar"]
  AnswerTests: omnitest(correctVal='vect["bar"]')
  Hint: Якщо нам треба елемент із іменем "bar" (другий у vect), якою командою його отримати?

- Class: cmd_question
  Output: Спробуй це зараз.
  CorrectAnswer: vect["bar"]
  AnswerTests: omnitest(correctExpr='vect["bar"]')
  Hint: Спробуй vect["bar"].

- Class: cmd_question
  Output: Так само можна задати вектор імен: vect[c("foo", "bar")]. Спробуй це.
  CorrectAnswer: vect[c("foo", "bar")]
  AnswerTests: omnitest(correctExpr='vect[c("foo", "bar")]')
  Hint: Використай vect[c("foo", "bar")], щоб отримати лише елементи vect з іменами "foo" та "bar".

- Class: text
  Output: Тепер ти знаєш усі чотири способи підмноження даних з векторів. Різні підходи кращі для різних ситуацій — якщо не впевнений, спробуй!

- Class: mult_question
  Output: Бажаєш проінформувати когось про успішне завершення цього уроку?
  CorrectAnswer: NULL
  AnswerChoices: Так; Ні
  AnswerTests: notify()
  Hint: NULL
