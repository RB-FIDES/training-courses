- Class: meta
  Course: R Programming_Alt
  Lesson: vapply and tapply
  Author: Nick Carchedi- переклад (oleksandkov | AI)
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.11

- Class: text
  Output: "У попередньому уроці ви дізналися про два основних представники сімейства функцій *apply в R: lapply() та sapply(). Обидві приймають список як вхідні дані, застосовують функцію до кожного елемента списку, а потім об'єднують і повертають результат. lapply() завжди повертає список, у той час як sapply() намагається спростити результат."

- Class: text
  Output: У цьому уроці ви навчитеся використовувати vapply() і tapply(), кожна з яких має дуже конкретне призначення у методології Split-Apply-Combine. Для послідовності ми використаємо той самий набір даних, що й у уроці 'lapply and sapply'.

- Class: text
  Output: "Набір даних Flags з UCI Machine Learning Repository містить деталі про різні країни та їхні прапори. Більше інформації можна знайти тут: http://archive.ics.uci.edu/ml/datasets/Flags"

- Class: text
  Output: Я зберіг дані у змінній під назвою flags. Якщо минув деякий час з уроку 'lapply and sapply', радимо знову ознайомитись з даними за допомогою функцій dim(), head(), str(), summary(). Також ви можете ввести viewinfo(), щоб переглянути документацію до цього набору даних. Починаємо!

- Class: cmd_question
  Output: Як ви бачили раніше, функція unique() повертає вектор унікальних значень, що містяться в об'єкті. Тому sapply(flags, unique) повертає список, який містить по одному вектору унікальних значень для кожного стовпця набору flags. Спробуйте це зараз.
  CorrectAnswer: sapply(flags, unique)
  AnswerTests: omnitest(correctExpr='sapply(flags, unique)')
  Hint: Використайте sapply(flags, unique), щоб отримати список по одному вектору унікальних значень для кожного стовпця набору flags.

- Class: text
  Output: А що якби ви забули, як працює unique(), і помилково подумали, що вона повертає *кількість* унікальних значень у переданому об'єкті? Тоді ви могли б неправильно очікувати, що sapply(flags, unique) поверне числовий вектор, оскільки кожен елемент списку містив би одне число, і sapply() міг би спростити результат до вектора.

- Class: text
  Output: При інтерактивній роботі це не страшно, бо ви одразу бачите результат і швидко помітите помилку. Але при написанні власних функцій така помилка може залишитися непоміченою і призвести до хибних результатів. Тому іноді варто перестрахуватися — для цього існує vapply().

- Class: text
  Output: На відміну від sapply(), яка намагається 'вгадати' формат результату, vapply() дозволяє явно його вказати. Якщо результат не відповідає заданому формату, vapply() видасть помилку і зупинить виконання. Це допоможе уникнути серйозних проблем у вашому коді через неочікувану поведінку sapply().

- Class: cmd_question
  Output: Спробуйте vapply(flags, unique, numeric(1)), тобто ви очікуєте, що кожен елемент результату буде числовим вектором довжини 1. Оскільки це НЕ так, ВИ ОТРИМАЄТЕ ПОМИЛКУ. Після появи помилки введіть ok(), щоб продовжити.
  CorrectAnswer: ok()
  AnswerTests: omnitest(correctExpr="ok()")
  Hint: Введіть vapply(flags, unique, numeric(1)), а потім ok(), щоб перейти далі.

- Class: cmd_question
  Output: Згадайте з попереднього уроку: sapply(flags, class) повертає символьний вектор з класом кожного стовпця. Спробуйте це ще раз.
  CorrectAnswer: sapply(flags, class)
  AnswerTests: omnitest(correctExpr="sapply(flags, class)")
  Hint: Введіть sapply(flags, class), щоб побачити класи стовпців.

- Class: cmd_question
  Output: Якщо хочете явно вказати очікуваний формат результату — використайте vapply(flags, class, character(1)). Аргумент character(1) означає, що ви очікуєте символьний вектор довжини 1 для кожного стовпця. Спробуйте.
  CorrectAnswer: vapply(flags, class, character(1))
  AnswerTests: omnitest(correctExpr="vapply(flags, class, character(1))")
  Hint: Використайте vapply(flags, class, character(1)), щоб отримати символьний вектор класів стовпців.

- Class: text
  Output: Зауважте: оскільки наш очікуваний результат був правильним (character(1)), результат vapply() ідентичний результату sapply() — символьний вектор класів стовпців.

- Class: text
  Output: Можна вважати vapply() 'безпечнішим', бо він вимагає вказати формат результату наперед, а не дозволяє R здогадуватись. До того ж vapply() може працювати швидше на великих наборах даних. Але при інтерактивному аналізі sapply() часто зручніший і швидший у написанні.

- Class: text
  Output: Як аналітик даних, ви часто захочете розбити дані на групи за значенням певної змінної, а потім застосувати функцію до кожної групи. Саме це робить tapply().

- Class: cmd_question
  Output: Використайте ?tapply, щоб відкрити документацію.
  CorrectAnswer: ?tapply
  AnswerTests: any_of_exprs('?tapply', 'help(tapply)')
  Hint: Відкрийте help-файл командою ?tapply.

- Class: cmd_question
  Output: Змінна 'landmass' у нашому наборі приймає значення від 1 до 6, кожне з яких — окрема частина світу. Використайте table(flags$landmass), щоб дізнатися, скільки країн у кожній групі.
  CorrectAnswer: table(flags$landmass)
  AnswerTests: omnitest(correctExpr="table(flags$landmass)")
  Hint: Використайте table(flags$landmass), щоб побачити розподіл по групах.

- Class: cmd_question
  Output: Змінна 'animate' набуває значення 1, якщо на прапорі є живий образ (наприклад, орел, дерево, рука), і 0 — якщо немає. Використайте table(flags$animate), щоб дізнатися, скільки прапорів містять анімований образ.
  CorrectAnswer: table(flags$animate)
  AnswerTests: omnitest(correctExpr="table(flags$animate)")
  Hint: Використайте table(flags$animate), щоб дізнатися, скільки прапорів містять анімований образ.

- Class: text
  Output: Це означає, що 39 прапорів містять анімований об'єкт (animate = 1), а 155 — не містять (animate = 0).

- Class: cmd_question
  Output: Якщо взяти середнє арифметичне з 0 і 1, отримаємо частку одиниць. Використайте tapply(flags$animate, flags$landmass, mean), щоб отримати частку прапорів з анімованим зображенням в кожній групі landmass.
  CorrectAnswer: tapply(flags$animate, flags$landmass, mean)
  AnswerTests: omnitest(correctExpr="tapply(flags$animate, flags$landmass, mean)")
  Hint: tapply(flags$animate, flags$landmass, mean) покаже частку прапорів з анімованим образом у кожній групі.

- Class: text
  Output: Перша група (landmass = 1, Північна Америка) має найвищу частку прапорів з анімованим зображенням (0.4194).

- Class: cmd_question
  Output: Так само можна подивитись підсумкову інформацію по чисельності населення (в мільйонах) для країн з червоним кольором на прапорі та без нього: tapply(flags$population, flags$red, summary).
  CorrectAnswer: tapply(flags$population, flags$red, summary)
  AnswerTests: omnitest(correctExpr="tapply(flags$population, flags$red, summary)")
  Hint: Ви можете побачити підсумок населення для країн з/без червоного кольору через tapply(flags$population, flags$red, summary).

- Class: mult_question  
  Output: Яке медіанне населення (у мільйонах) у країн *без* червоного кольору на прапорі?
  AnswerChoices: 9.0; 4.0; 27.6; 3.0; 22.1; 0.0
  CorrectAnswer: 3.0
  AnswerTests: omnitest(correctVal= '3.0')
  Hint: Скористайтесь попереднім результатом. red = 0 означає, що червоного на прапорі немає.

- Class: cmd_question
  Output: Нарешті, подивіться підсумок чисельності населення для кожної з шести частин світу: tapply(flags$population, flags$landmass, summary).
  CorrectAnswer: tapply(flags$population, flags$landmass, summary)
  AnswerTests: omnitest(correctExpr="tapply(flags$population, flags$landmass, summary)")
  Hint: Дивіться підсумок населення по landmass: tapply(flags$population, flags$landmass, summary).

- Class: mult_question  
  Output: Яке максимальне населення (у мільйонах) у четвертій групі (Африка)?
  AnswerChoices: 56.00; 1010.0; 119.0; 5.00; 157.00
  CorrectAnswer: 56.00
  AnswerTests: omnitest(correctVal= '56.00')
  Hint: Скористайтеся попереднім результатом.

- Class: text  
  Output: У цьому уроці ви дізналися, як використовувати vapply() як безпечнішу альтернативу sapply(), особливо при написанні власних функцій. Ви також навчилися користуватися tapply() для розбиття даних на групи та застосування функції до кожної групи. Ці інструменти стануть у пригоді на шляху до майстерності у аналізі даних.

- Class: mult_question
  Output: Бажаєте повідомити когось про успішне завершення цього уроку?
  CorrectAnswer: NULL
  AnswerChoices: Так; Ні
  AnswerTests: notify()
  Hint: NULL
