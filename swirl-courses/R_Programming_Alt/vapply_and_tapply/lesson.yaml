- Class: meta
  Course: R Programming_Alt
  Lesson: vapply and tapply
  Author: Nick Carchedi - переклад (oleksandkov | AI)
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.11

- Class: text
  Output: "У попередньому уроці ти дізналася про двох основних представників сімейства функцій *apply в R: lapply() та sapply(). Обидві приймають список як вхідні дані, застосовують функцію до кожного елемента списку, а потім об'єднують і повертають результат. lapply() завжди повертає список, у той час як sapply() намагається спростити результат."

- Class: text
  Output: "У цьому уроці ти навчишся використовувати vapply() і tapply(), кожна з яких має дуже конкретне призначення у методології Split-Apply-Combine. Для послідовності ми використаємо той самий набір даних, що й у уроці 'lapply and sapply'."

- Class: text
  Output: "Набір даних Flags з UCI Machine Learning Repository містить деталі про різні країни та їхні прапори. Більше інформації можна знайти тут: http://archive.ics.uci.edu/ml/datasets/Flags"

- Class: text
  Output: "Я зберіг дані у змінній під назвою flags. Якщо минув деякий час з уроку 'lapply and sapply', раджу знову ознайомитись з даними за допомогою функцій dim(), head(), str(), summary(). Також можеш ввести viewinfo(), щоб переглянути документацію до цього набору даних. Починаємо!"

- Class: cmd_question
  Output: "Як ти бачила раніше, функція unique() повертає вектор унікальних значень, що містяться в об'єкті. Тому sapply(flags, unique) повертає список, який містить по одному вектору унікальних значень для кожного стовпця набору flags. Спробуй це зараз."
  CorrectAnswer: sapply(flags, unique)
  AnswerTests: omnitest(correctExpr='sapply(flags, unique)')
  Hint: "Використай sapply(flags, unique), щоб отримати список по одному вектору унікальних значень для кожного стовпця набору flags."

- Class: text
  Output: "А що якби ти забула, як працює unique(), і помилково подумала, що вона повертає *кількість* унікальних значень у переданому об'єкті? Тоді ти могла б неправильно очікувати, що sapply(flags, unique) поверне числовий вектор, оскільки кожен елемент списку містив би одне число, і sapply() міг би спростити результат до вектора."

- Class: text
  Output: "При інтерактивній роботі це не страшно, бо ти одразу бачиш результат і швидко помітиш помилку. Але при написанні власних функцій така помилка може залишитися непоміченою і призвести до хибних результатів. Тому іноді варто перестрахуватися — для цього існує vapply()."

- Class: text
  Output: "На відміну від sapply(), яка намагається 'вгадати' формат результату, vapply() дозволяє явно його вказати. Якщо результат не відповідає заданому формату, vapply() видасть помилку і зупинить виконання. Це допоможе уникнути серйозних проблем у твоєму коді через неочікувану поведінку sapply()."

- Class: cmd_question
  Output: "Спробуй vapply(flags, unique, numeric(1)), тобто ти очікуєш, що кожен елемент результату буде числовим вектором довжини 1. Оскільки це НЕ так, ТИ ОТРИМАЄШ ПОМИЛКУ. Після появи помилки введи ok(), щоб продовжити."
  CorrectAnswer: ok()
  AnswerTests: omnitest(correctExpr="ok()")
  Hint: "Введи vapply(flags, unique, numeric(1)), а потім ok(), щоб перейти далі."

- Class: cmd_question
  Output: "Згадай з попереднього уроку: sapply(flags, class) повертає символьний вектор з класом кожного стовпця. Спробуй це ще раз."
  CorrectAnswer: sapply(flags, class)
  AnswerTests: omnitest(correctExpr="sapply(flags, class)")
  Hint: "Введи sapply(flags, class), щоб побачити класи стовпців."

- Class: cmd_question
  Output: "Якщо хочеш явно вказати очікуваний формат результату — використай vapply(flags, class, character(1)). Аргумент character(1) означає, що ти очікуєш символьний вектор довжини 1 для кожного стовпця. Спробуй."
  CorrectAnswer: vapply(flags, class, character(1))
  AnswerTests: omnitest(correctExpr="vapply(flags, class, character(1))")
  Hint: "Використай vapply(flags, class, character(1)), щоб отримати символьний вектор класів стовпців."

- Class: text
  Output: "Зауваж: оскільки наш очікуваний результат був правильним (character(1)), результат vapply() ідентичний результату sapply() — символьний вектор класів стовпців."

- Class: text
  Output: "Можна вважати vapply() 'безпечнішим', бо він вимагає вказати формат результату наперед, а не дозволяє R здогадуватись. До того ж vapply() може працювати швидше на великих наборах даних. Але при інтерактивному аналізі sapply() часто зручніший і швидший у написанні."

- Class: text
  Output: "Як аналітик даних, ти часто захочеш розбити дані на групи за значенням певної змінної, а потім застосувати функцію до кожної групи. Саме це робить tapply()."

- Class: cmd_question
  Output: "Використай ?tapply, щоб відкрити документацію."
  CorrectAnswer: ?tapply
  AnswerTests: any_of_exprs('?tapply', 'help(tapply)')
  Hint: "Відкрий help-файл командою ?tapply."

- Class: cmd_question
  Output: "Змінна 'landmass' у нашому наборі приймає значення від 1 до 6, кожне з яких — окрема частина світу. Використай table(flags$landmass), щоб дізнатися, скільки країн у кожній групі."
  CorrectAnswer: table(flags$landmass)
  AnswerTests: omnitest(correctExpr="table(flags$landmass)")
  Hint: "Використай table(flags$landmass), щоб побачити розподіл по групах."

- Class: cmd_question
  Output: "Змінна 'animate' набуває значення 1, якщо на прапорі є живий образ (наприклад, орел, дерево, рука), і 0 — якщо немає. Використай table(flags$animate), щоб дізнатися, скільки прапорів містять анімований образ."
  CorrectAnswer: table(flags$animate)
  AnswerTests: omnitest(correctExpr="table(flags$animate)")
  Hint: "Використай table(flags$animate), щоб дізнатися, скільки прапорів містять анімований образ."

- Class: text
  Output: "Це означає, що 39 прапорів містять анімований об'єкт (animate = 1), а 155 — не містять (animate = 0)."

- Class: cmd_question
  Output: "Якщо взяти середнє арифметичне з 0 і 1, отримаємо частку одиниць. Використай tapply(flags$animate, flags$landmass, mean), щоб отримати частку прапорів з анімованим зображенням в кожній групі landmass."
  CorrectAnswer: tapply(flags$animate, flags$landmass, mean)
  AnswerTests: omnitest(correctExpr="tapply(flags$animate, flags$landmass, mean)")
  Hint: "tapply(flags$animate, flags$landmass, mean) покаже частку прапорів з анімованим образом у кожній групі."

- Class: text
  Output: "Перша група (landmass = 1, Північна Америка) має найвищу частку прапорів з анімованим зображенням (0.4194)."

- Class: cmd_question
  Output: "Так само можна подивитись підсумкову інформацію по чисельності населення (в мільйонах) для країн з червоним кольором на прапорі та без нього: tapply(flags$population, flags$red, summary)."
  CorrectAnswer: tapply(flags$population, flags$red, summary)
  AnswerTests: omnitest(correctExpr="tapply(flags$population, flags$red, summary)")
  Hint: "Ти можеш побачити підсумок населення для країн з/без червоного кольору через tapply(flags$population, flags$red, summary)."

- Class: mult_question  
  Output: "Яке медіанне населення (у мільйонах) у країн *без* червоного кольору на прапорі?"
  AnswerChoices: 9.0; 4.0; 27.6; 3.0; 22.1; 0.0
  CorrectAnswer: 3.0
  AnswerTests: omnitest(correctVal= '3.0')
  Hint: "Скористайся попереднім результатом. red = 0 означає, що червоного на прапорі немає."

- Class: cmd_question
  Output: "Нарешті, подивись підсумок чисельності населення для кожної з шести частин світу: tapply(flags$population, flags$landmass, summary)."
  CorrectAnswer: tapply(flags$population, flags$landmass, summary)
  AnswerTests: omnitest(correctExpr="tapply(flags$population, flags$landmass, summary)")
  Hint: "Подивись підсумок населення по landmass: tapply(flags$population, flags$landmass, summary)."

- Class: mult_question  
  Output: "Яке максимальне населення (у мільйонах) у четвертій групі (Африка)?"
  AnswerChoices: 56.00; 1010.0; 119.0; 5.00; 157.00
  CorrectAnswer: 56.00
  AnswerTests: omnitest(correctVal= '56.00')
  Hint: "Скористайся попереднім результатом."

- Class: text  
  Output: "У цьому уроці ти дізналася, як використовувати vapply() як безпечнішу альтернативу sapply(), особливо при написанні власних функцій. Ти також навчилася користуватися tapply() для розбиття даних на групи та застосування функції до кожної групи. Ці інструменти стануть у пригоді на шляху до майстерності у аналізі даних."

- Class: mult_question
  Output: "Бажаєш повідомити когось про успішне завершення цього уроку?"
  CorrectAnswer: NULL
  AnswerChoices: Так; Ні
  AnswerTests: notify()
  Hint: NULL

