- Class: meta
  Course: R Programming_Alt
  Lesson: lapply and sapply
  Author: Nick Carchedi- переклад (oleksandkov | AI)
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.11

- Class: text
  Output: У цьому уроці ти навчишся використовувати lapply() та sapply() — дві найважливіші функції з родини *apply в R, також відомі як функції-цикли.

- Class: text
  Output: Ці потужні функції, а також їх найближчі родичі (vapply(), tapply() та інші) надають зручний і стислий спосіб реалізації стратегії "Розділи-Застосуй-Об’єднай" (Split-Apply-Combine) для аналізу даних.

- Class: text
  Output: Кожна з функцій *apply РОЗДІЛЯЄ дані на менші частини, ЗАСТОСОВУЄ функцію до кожної частини, а потім ОБ’ЄДНУЄ результати. Детальніше про цю стратегію можна прочитати у статті Hadley Wickham у Journal of Statistical Software — "The Split-Apply-Combine Strategy for Data Analysis".

- Class: text
  Output: "Протягом цього уроку ми будемо використовувати набір даних Flags з UCI Machine Learning Repository. Цей набір містить інформацію про різні країни та їх прапори. Детальніше: http://archive.ics.uci.edu/ml/datasets/Flags"

- Class: text
  Output: Давай одразу перейдемо до справи, щоб відчути як працюють ці особливі функції!

- Class: cmd_question
  Output: Я зберіг набір даних у змінній flags. Введи head(flags), щоб переглянути перші шість рядків (тобто "голову") таблиці.
  CorrectAnswer: head(flags)
  AnswerTests: omnitest(correctExpr='head(flags)')
  Hint: Введи head(flags), щоб побачити "голову" набору даних.

- Class: cmd_question
  Output: Можливо, доведеться прокрутити вгору, щоб побачити весь вивід. Тепер дізнаємося розміри таблиці за допомогою dim(flags).
  CorrectAnswer: dim(flags)
  AnswerTests: omnitest(correctExpr='dim(flags)')
  Hint: Введи dim(flags), щоб переглянути розміри набору даних.

- Class: text
  Output: Це означає, що у нас 194 рядки (спостереження) й 30 стовпців (змінних). Кожен рядок — це країна, а кожна змінна описує характеристику цієї країни або її прапора. Для докладнішого опису набору даних відкрий окремий текстовий файл за допомогою viewinfo(), коли повернешся до промпту (>).

- Class: cmd_question
  Output: Як і з будь-яким набором даних, нам цікаво у якому форматі зберігаються змінні. Тобто, який "клас" кожної змінної? Що буде, якщо виконати class(flags)? Спробуй.
  CorrectAnswer: class(flags)
  AnswerTests: omnitest(correctExpr='class(flags)')
  Hint: Введи class(flags), щоб подивитись результат.

- Class: text
  Output: Це лише показує, що весь набір — це "data.frame", але не відповідає на питання про типи окремих змінних. Насправді треба викликати class() для кожного стовпця окремо. Можна зробити це вручну, але набагато швидше автоматизувати — наприклад, через цикл!

- Class: text
  Output: Функція lapply() приймає список, застосовує до кожного елемента функцію і повертає список тієї ж довжини. Оскільки data.frame — це просто список векторів (перевір це через as.list(flags)), можна використати lapply(), щоб застосувати class() до кожного стовпця таблиці. Подивимось на це!

- Class: cmd_question
  Output: Введи cls_list <- lapply(flags, class), щоб застосувати class() до кожного стовпця набору даних flags і зберегти результат у змінну cls_list. Зверни увагу: потрібно просто вказати назву функції (class), без дужок.
  CorrectAnswer: cls_list <- lapply(flags, class)
  AnswerTests: omnitest(correctExpr='cls_list <- lapply(flags, class)')
  Hint: Введи cls_list <- lapply(flags, class), щоб застосувати class() до кожного стовпця та зберегти в cls_list.

- Class: cmd_question
  Output: Введи cls_list, щоб переглянути результат.
  CorrectAnswer: cls_list
  AnswerTests: omnitest(correctExpr='cls_list')
  Hint: Введи cls_list, щоб побачити результат.

- Class: cmd_question
  Output: "l" у "lapply" означає "list". Введи class(cls_list), щоб переконатися, що lapply() повернула список.
  CorrectAnswer: class(cls_list)
  AnswerTests: omnitest(correctExpr='class(cls_list)')
  Hint: Введи class(cls_list), щоб переконатися, що результат — список.

- Class: text
  Output: Як і очікувалось, ми отримали список із 30 елементів — по одному на кожну змінну. Вивід був би компактнішим, якби ми представили його у вигляді вектора, а не списку.

- Class: cmd_question
  Output: Ти вже знаєш, що списки зручно використовувати для зберігання різних типів даних. Але тут кожен елемент — це character-вектор довжини один ("integer", "vector" тощо), тому cls_list можна перетворити на character-вектор. Для цього вручну введи as.character(cls_list).
  CorrectAnswer: as.character(cls_list)
  AnswerTests: omnitest(correctExpr='as.character(cls_list)')
  Hint: Введи as.character(cls_list), щоб перетворити cls_list на character-вектор.

- Class: cmd_question
  Output: sapply() дозволяє автоматизувати цей процес: вона викликає lapply(), а потім намагається "спростити" (звідси "s" у sapply) результат. Використай sapply() так само, як і lapply(), щоб отримати класи всіх стовпців таблиці flags і зберегти результат у cls_vect. Якщо потрібно, скористайся ?sapply.
  CorrectAnswer: cls_vect <- sapply(flags, class)
  AnswerTests: omnitest(correctExpr='cls_vect <- sapply(flags, class)')
  Hint: Введи cls_vect <- sapply(flags, class), щоб зберегти класи стовпців у cls_vect.

- Class: cmd_question
  Output: Використай class(cls_vect), щоб переконатися, що sapply() спростила результат до character-вектора.
  CorrectAnswer: class(cls_vect)
  AnswerTests: omnitest(correctExpr='class(cls_vect)')
  Hint: Введи class(cls_vect), щоб перевірити, що sapply() повернула character-вектор.

- Class: text
  Output: Якщо результат — це список, де кожен елемент довжини 1, sapply() повертає вектор. Якщо елементи — вектори однакової довжини (>1), sapply() повертає матрицю. Якщо sapply() не може спростити результат — просто повертає список, як lapply().

- Class: text
  Output: Давай ще трохи попрактикуємося з lapply() та sapply()!

- Class: text
  Output: Стовпці 11–17 у нашому наборі — це індикаторні змінні: кожна означає наявність певного кольору на прапорі. Якщо колір є — значення 1, якщо немає — 0.

- Class: cmd_question
  Output: Тому, щоб дізнатися скільки країн (у нашому наборі) мають, наприклад, помаранчевий на прапорі, достатньо підсумувати всі 1 і 0 у стовпці 'orange'. Спробуй sum(flags$orange).
  CorrectAnswer: sum(flags$orange)
  AnswerTests: omnitest(correctExpr='sum(flags$orange)')
  Hint: Використай sum(flags$orange), щоб порахувати всі 1 і 0 у стовпці 'orange'.

- Class: text
  Output: Тепер виконаємо цю операцію для кожного кольору, який є у наборі.

- Class: cmd_question
  Output: Спочатку використовуй flag_colors <- flags[, 11:17], щоб виділити стовпці з кольорами і зберегти їх у новий data frame flag_colors. (Зверни увагу на кому перед 11:17. Ця команда означає "всі рядки, але лише стовпці 11-17").
  CorrectAnswer: flag_colors <- flags[, 11:17]
  AnswerTests: omnitest(correctExpr='flag_colors <- flags[, 11:17]')
  Hint: flag_colors <- flags[, 11:17] зробить потрібне!

- Class: cmd_question
  Output: Використай head(), щоб подивитися перші 6 рядків flag_colors.
  CorrectAnswer: head(flag_colors)
  AnswerTests: omnitest(correctExpr='head(flag_colors)')
  Hint: head(flag_colors) покаже перші шість рядків flag_colors.

- Class: cmd_question
  Output: Щоб отримати список із сум кожного стовпця flag_colors, виклич lapply() із двома аргументами: об’єкт для циклу (flag_colors) і назву функції (sum). Пам’ятай: лише назва функції, без дужок!
  CorrectAnswer: lapply(flag_colors, sum)
  AnswerTests: omnitest(correctExpr='lapply(flag_colors, sum)')
  Hint: Використай lapply(flag_colors, sum), щоб отримати суму кожного стовпця.

- Class: text
  Output: Це показує, що з 194 прапорів у нашому наборі 153 містять червоний, 91 — зелений, 99 — синій і так далі.

- Class: cmd_question
  Output: Результат — список, бо lapply() завжди повертає список. Кожен елемент — довжини 1, отже можна спростити до вектора через sapply(). Спробуй зараз.
  CorrectAnswer: sapply(flag_colors, sum)
  AnswerTests: omnitest(correctExpr='sapply(flag_colors, sum)')
  Hint: Використай sapply(flag_colors, sum), щоб отримати вектор сум.

- Class: text
  Output: Можливо, цікавіше знайти частку прапорів (з 194), які містять кожен колір. Оскільки кожен стовпець — це просто 1 та 0, середнє арифметичне кожного стовпця дасть частку 1. (Якщо це не очевидно, уяви три одиниці й два нулі: (1+1+1+0+0)/5 = 0.6).

- Class: cmd_question
  Output: Використай sapply(), щоб застосувати mean() до кожного стовпця flag_colors. Другий аргумент sapply() — просто mean (без дужок).
  CorrectAnswer: sapply(flag_colors, mean)
  AnswerTests: omnitest(correctExpr='sapply(flag_colors, mean)')
  Hint: sapply(flag_colors, mean) зробить усе необхідне!

- Class: text
  Output: У попередніх прикладах sapply() могла спростити результат до вектора, бо кожен елемент списку був вектором довжини 1. Нагадаймо: якщо всі елементи списку — вектори однакової довжини (>1), sapply() повертає матрицю.

- Class: cmd_question
  Output: Щоб це побачити, виділи стовпці з 19 по 23 з flags і збережи в новий data frame flag_shapes. flag_shapes <- flags[, 19:23] — саме так.
  CorrectAnswer: flag_shapes <- flags[, 19:23]
  AnswerTests: omnitest(correctExpr='flag_shapes <- flags[, 19:23]')
  Hint: flag_shapes <- flags[, 19:23] зберігає стовпці 19–23 у нову змінну.

- Class: text
  Output: Кожен із цих стовпців — це кількість разів, коли певна форма чи елемент трапляється на прапорі країни. Нас цікавлять мінімальні та максимальні значення для кожної форми.

- Class: cmd_question
  Output: Функція range() повертає мінімум і максимум свого аргументу — числового вектора. Використай lapply(), щоб застосувати range до кожного стовпця flag_shapes. Можна не зберігати результат — lapply() завжди повертає список.
  CorrectAnswer: lapply(flag_shapes, range)
  AnswerTests: omnitest(correctExpr='lapply(flag_shapes, range)')
  Hint: lapply(flag_shapes, range) застосує range() до кожного стовпця flag_shapes.

- Class: cmd_question
  Output: Зроби те саме, але через sapply() й збережи в змінну shape_mat.
  CorrectAnswer: shape_mat <- sapply(flag_shapes, range)
  AnswerTests: omnitest(correctExpr='shape_mat <- sapply(flag_shapes, range)')
  Hint: shape_mat <- sapply(flag_shapes, range) застосує range() до кожного стовпця flag_shapes і збереже результат у shape_mat.

- Class: cmd_question
  Output: Подивись вміст shape_mat.
  CorrectAnswer: shape_mat
  AnswerTests: any_of_exprs('shape_mat', 'print(shape_mat)')
  Hint: Введи shape_mat, щоб переглянути результат.

- Class: text
  Output: Кожен стовпець shape_mat містить мінімум (1 рядок) і максимум (2 рядок) для відповідної форми у різних прапорах.

- Class: cmd_question
  Output: Використай class(), щоб переконатися, що shape_mat — це матриця.
  CorrectAnswer: class(shape_mat)
  AnswerTests: omnitest(correctExpr='class(shape_mat)')
  Hint: class(shape_mat) поверне клас shape_mat.

- Class: text
  Output: Як бачиш, sapply() завжди намагається спростити результат lapply(). Дотепер їй це вдавалося. Давай подивимося, коли sapply() не може спростити результат і повертає список — як lapply().

- Class: cmd_question
  Output: Якщо надати функції unique() вектор, вона поверне вектор лише з унікальними елементами. Спробуй unique(c(3, 4, 5, 5, 5, 6, 6)), щоб побачити як це працює.
  CorrectAnswer: unique(c(3, 4, 5, 5, 5, 6, 6))
  AnswerTests: omnitest(correctExpr='unique(c(3, 4, 5, 5, 5, 6, 6))')
  Hint: Спробуй unique(c(3, 4, 5, 5, 5, 6, 6)), щоб побачити як працює unique().

- Class: cmd_question
  Output: Ми хочемо знати унікальні значення для кожної змінної flags. Для цього використай lapply(), щоб застосувати unique() до кожного стовпця flags, і збережи результат у unique_vals.
  CorrectAnswer: unique_vals <- lapply(flags, unique)
  AnswerTests: omnitest(correctExpr='unique_vals <- lapply(flags, unique)')
  Hint: Спробуй unique_vals <- lapply(flags, unique).

- Class: cmd_question
  Output: Виведи значення unique_vals у консоль.
  CorrectAnswer: unique_vals
  AnswerTests: any_of_exprs('unique_vals', 'print(unique_vals)')
  Hint: Введи unique_vals, щоб побачити його вміст.

- Class: cmd_question
  Output: "Оскільки unique_vals — це список, ти можеш підрахувати довжину кожного елемента (тобто кількість унікальних значень у кожній змінній). Спрости результат, якщо можливо. Підказка: застосуй length() до кожного елемента unique_vals."
  CorrectAnswer: sapply(unique_vals, length)
  AnswerTests: omnitest(correctExpr='sapply(unique_vals, length)')
  Hint: Застосуй length() до кожного елемента unique_vals через sapply(). Лише назва функції: length.

- Class: text
  Output: Те, що елементи unique_vals — вектори різної довжини, створює проблему для sapply(): немає очевидного способу спростити результат.

- Class: cmd_question
  Output: Використай sapply(), щоб застосувати unique() до кожного стовпця flags і побачиш, що отримаєш такий самий "неспростимий" список, як і з lapply().
  CorrectAnswer: sapply(flags, unique)
  AnswerTests: omnitest(correctExpr='sapply(flags, unique)')
  Hint: Використай sapply(flags, unique), щоб побачити: результат не буде спрощено.

- Class: text
  Output: Іноді потрібно застосувати функцію, якої ще не існує, тобто написати власну. Написання функцій у R виходить за межі цього уроку, але давай розглянемо швидкий приклад у контексті lapply().

- Class: text
  Output: Уяви, що тебе цікавить лише другий елемент у кожному векторі списку unique_vals. Оскільки немає готової функції, яка повертає другий елемент вектора, створимо власну.

- Class: cmd_question
  Output: lapply(unique_vals, function(elem) elem[2]) поверне список із другим елементом кожного унікального значення. Зверни увагу: функція приймає один аргумент elem — це "змінна-заглушка", яка по черзі приймає значення кожного елемента unique_vals.
  CorrectAnswer: lapply(unique_vals, function(elem) elem[2])
  AnswerTests: calculates_same_value('lapply(unique_vals, function(elem) elem[2])')
  Hint: Використай lapply(unique_vals, function(elem) elem[2]), щоб отримати список других елементів.

- Class: text
  Output: Єдина відмінність від попередніх прикладів — тут ми визначаємо й використовуємо власну функцію прямо у виклику lapply(). Вона не має імені й зникає після виконання lapply(). Такі "анонімні функції" дуже зручні, коли немає потрібної функції серед вбудованих.

- Class: text
  Output: У цьому уроці ти дізнався, як використовувати потужні lapply() та sapply(), щоб застосувати операцію до елементів списку. У наступному уроці ми розглянемо їхніх найближчих "родичів".

- Class: mult_question
  Output: Хочеш повідомити когось про успішне завершення цього уроку?
  CorrectAnswer: NULL
  AnswerChoices: Так; Ні
  AnswerTests: notify()
  Hint: NULL
