- Class: meta
  Course: R_Programming_UA_ENG
  Lesson: Vectors 
  Author: Nick Carchedi - переклад (halyna.liubchych)
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.0

- Class: text
  Output: "Вокабуляр цього уроку. Vector - вектор, data structure - структура даних, numeric vector - числовий вектор, atomic vector - атомарний вектор, list - список, available - доступний, not available - недоступно, logical - логічний, logical operator - логічний оператор, character - символьний, integer - ціле число, complex - комплексне число, condition - умова, element-by-element - елемент за едементом, to collapse - зруйнуватися, your - твій, name - імʼя, here - тут, to coerced - примушувати." 
  
- Class: text
  Output: Найпростіша і найпоширеніша структура даних (data structure) в R - це vector (вектор).

- Class: text
  Output: 'Вектори бувають двох різних типів: atomic vectors (атомарні вектори) і lists (списки). Атомарний вектор містить тільки один тип даних, тоді як список може містити кілька типів даних. Перш ніж перейти до списків, дослідимо атомарні вектори.'

- Class: text
  Output: У попередніх уроках ми мали справу виключно з numeric vectors (числовими векторами), які є одним з типів атомарних векторів. Інші типи: logical (логічні), character (символьні), integer (цілі числа) та complex (комплексні числа). У цьому уроці ми детальніше розглянемо логічні та символьні вектори.

- Class: text
  Output: Логічні вектори можуть містити значення TRUE, FALSE та NA (для 'not available' - недоступно). Ці значення генеруються як результат логічних 'умов' (conditions). Давай поекспериментуємо з деякими простими умовами.

- Class: cmd_question
  Output: Спочатку створи числовий вектор num_vect, який має значення 0.5, 55, -10 та 6.
  CorrectAnswer: num_vect <- c(0.5, 55, -10, 6)
  AnswerTests: omnitest(correctExpr='num_vect <- c(0.5, 55, -10, 6)')
  Hint: Пам'ятай, що функція c() використовується для створення вектора. Не забудь присвоїти результат новій змінній num_vect.

- Class: cmd_question
  Output: Тепер створи змінну tf, яка отримає результат num_vect < 1, що читається як 'num_vect менше за 1'.
  CorrectAnswer: tf <- num_vect < 1
  AnswerTests: omnitest(correctExpr='tf <- num_vect < 1')
  Hint: Використай tf <- num_vect < 1, щоб присвоїти результат num_vect < 1 змінній tf.

- Class: mult_question
  Output: Як ти думаєш, як буде виглядати tf?
  CorrectAnswer: вектор з 4 логічних значень
  AnswerChoices: вектор з 4 логічних значень; одне логічне значення
  AnswerTests: omnitest(correctVal='вектор з 4 логічних значень')
  Hint: Пам'ятаєш наш урок про векторну арифметику? Основна ідея полягала в тому, що R виконує багато операцій поелементно (element-by-element). Ми називали такі операції 'векторизованими' (vectorized).

- Class: cmd_question
  Output: Виведи вміст tf зараз.
  CorrectAnswer: tf
  AnswerTests: omnitest(correctExpr='tf')
  Hint: Просто набери tf і натисни Enter, щоб переглянути її значення.

- Class: text
  Output: Вираз num_vect < 1 є умовою, і tf показує нам, чи кожен відповідний елемент нашого числового вектора num_vect задовольняє цю умову.

- Class: text
  Output: Перший елемент num_vect дорівнює 0.5, що менше за 1, тому вираз 0.5 < 1 є TRUE. Другий елемент num_vect дорівнює 55, що більше за 1, тому вираз 55 < 1 є FALSE. Та сама логіка застосовується для третього і четвертого елементів.

- Class: cmd_question
  Output: Спробуємо ще один. Набери num_vect >= 6, не присвоюючи результат новій змінній.
  CorrectAnswer: num_vect >= 6
  AnswerTests: omnitest(correctExpr='num_vect >= 6')
  Hint: Не створюй нову змінну для цього. Ми просто хочемо побачити результат num_vect >= 6. Переконайся, що немає пробілу між символами `>` і `=`. Думай про них як про один символ 'більше або дорівнює'.

- Class: text
  Output: Цього разу ми запитуємо, чи кожен окремий елемент num_vect більший АБО дорівнює 6. Оскільки тільки 55 і 6 більші або дорівнюють 6, другий і четвертий елементи результату є TRUE, а перший і третій елементи - FALSE.

- Class: text
  Output: Символи `<` і `>=` у цих прикладах називаються 'логічними операторами' (logical operators). Інші логічні оператори включають `>`, `<=`, `==` для точної рівності та `!=` для нерівності.

- Class: text
  Output: Якщо ми маємо два логічні вирази, A і B, ми можемо запитати, чи принаймні один з них TRUE за допомогою A | B (логічне 'або', також відоме як 'об'єднання'), або чи обидва TRUE за допомогою A & B (логічне 'і', також відоме як 'перетин'). Ї Нарешті, !A - це заперечення A. Якщо A є FALSE, то !A (не А) є TRUE.

- Class: text
  Output: Варто приділити деякий час експериментам з різними комбінаціями цих логічних операторів, поки ти не почуватимешся комфортно використовуючи їх. Давай зробимо кілька прикладів, треба ж з чогось починати.

- Class: text
  Output: Постарайся передбачити результат кожного з наступних виразів. Ти можеш записувати свої прогнози, використовуючи ручку і блокнот, якщо так тобі зручно. Якщо застрягнеш, просто вгадуй - вірогідність правильної відповіді 50%, чесно!

- Class: mult_question
  Output: (3 > 5) & (4 == 4)
  CorrectAnswer: 'FALSE'
  AnswerChoices: TRUE; FALSE
  AnswerTests: omnitest(correctVal='FALSE')
  Hint: Розбий цю проблему на дві частини. `&` посередині означає, що ОБИДВІ частини TRUE. Твоє завдання - з'ясувати, чи це точне твердження. Якщо так, вся умова TRUE. Якщо ні, то FALSE.

- Class: mult_question
  Output: (TRUE == TRUE) | (TRUE == FALSE)
  CorrectAnswer: 'TRUE'
  AnswerChoices: TRUE; FALSE
  AnswerTests: omnitest(correctVal='TRUE')
  Hint: Розбий цю проблему на 2 частини. `|` посередині означає, що ПРИНАЙМНІ ОДНА з частин TRUE. Твоє завдання - з'ясувати, чи це точне твердження. Якщо так, вся умова TRUE. Якщо ні, то FALSE.

- Class: mult_question
  Output: ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)
  CorrectAnswer: 'TRUE'
  AnswerChoices: TRUE; FALSE
  AnswerTests: omnitest(correctVal='TRUE')
  Hint: Це складне завдання. Пам'ятай, що символ `!` заперечує все, що йде після нього. Тут також діє 'порядок операцій'. Умови, що знаходяться в дужках, слід обчислювати першими.

- Class: text
  Output: Не хвилюйся, якщо ці завдання здалися тобі складними. Вони мають бути такими. Робота з логічними виразами в R потребує практики, але твої зусилля будуть винагороджені в майбутніх уроках (наприклад, в роботі з підмножинами та структурами управління).

- Class: text
  Output: Символьні вектори (character vectors) також дуже поширені в R. Подвійні лапки використовуються для розрізнення символьних об'єктів, як у наступному прикладі.

- Class: cmd_question
  Output: 'Створи символьний вектор, який містить наступні слова: "Мене", "звати". Не забувай писати кожне слово у подвійних лапках, щоб R знав, що це символьні рядки (character strings). Збережи вектор у змінній my_char.'
  CorrectAnswer: my_char <- c("Мене", "звати")
  AnswerTests: omnitest(correctExpr='my_char <- c("Мене", "звати")')
  Hint: Набери my_char <- c("Мене", "звати"), щоб створити нову змінну my_char, яка містить символьний вектор довжиною 2. Переконайся, що коми, які розділяють слова, знаходяться ПОЗА подвійними лапками, інакше R сприйматиме їх, як частину слова.

- Class: cmd_question
  Output: Виведи вміст my_char, щоб побачити, як це виглядає.
  CorrectAnswer: my_char
  AnswerTests: omnitest(correctExpr='my_char')
  Hint: Набери my_char, щоб переглянути її вміст.

- Class: text
  Output: Зараз my_char - це символьний вектор довжиною 2. Скажімо, ми хочемо з'єднати елементи my_char разом в один безперервний символьний рядок (тобто символьний вектор довжиною 1). Ми можемо зробити це, використовуючи функцію paste().

- Class: cmd_question
  Output: Набери paste(my_char, collapse = " ") зараз. Переконайся, що є пробіл між подвійними лапками в аргументі `collapse`. Ти побачиш, чому, за секунду.
  CorrectAnswer: paste(my_char, collapse = " ")
  AnswerTests: omnitest(correctExpr='paste(my_char, collapse = " ")')
  Hint: Використай paste(my_char, collapse = " "), щоб обʼєднати слова у векторі так, щоб вони майже утворили речення. Між подвійними лапками в аргументі `collapse` має бути один пробіл, щоб були окремі пробіли, що розділяють слова.

- Class: text
  Output: Аргумент `collapse` функції paste() вказує R, що при з'єднані елементів символьного вектора my_char, ми хочемо розділити їх одинарними пробілами.

- Class: text
  Output: Здається, нам чогось бракує... Звісно! Твого імені!

- Class: cmd_question
  Output: 'Щоб додати (або 'конкатенувати') твоє ім'я до кінця my_char, використай функцію c() ось так: c(my_char, "your_name_here"). Напиши своє імʼя замість your_name_here і не забудь лапки. Спробуй зараз, збережи результат у новій змінній my_name.'
  CorrectAnswer: my_name <- c(my_char, "Swirl")
  AnswerTests: var_is_a("character", "my_name"); expr_uses_func("c"); expr_creates_var("my_name");
    val_has_length(4)
  Hint: Додай своє ім'я в кінці вектора my_char, використовуючи функцію c(). Переконайся, що присвоюєш результат новій змінній my_name. Якби тебе звали "Swirl", то нова зміна виглядала б так: my_name <- c(my_char, "Swirl").

- Class: cmd_question
  Output: Подивись на вміст my_name.
  CorrectAnswer: my_name
  AnswerTests: omnitest(correctExpr='my_name')
  Hint: Набери my_name і натисни Enter, щоб переглянути її вміст.

- Class: cmd_question
  Output: Тепер використай функцію paste() ще раз, щоб з'єднати слова в my_name разом в один символьний рядок. Не забудь сказати collapse = " "!
  CorrectAnswer: paste(my_name, collapse = " ")
  AnswerTests: omnitest(correctExpr='paste(my_name, collapse = " ")')
  Hint: Використай paste(my_name, collapse = " "), щоб з'єднати три слова разом і розділити їх одинарними пробілами.

- Class: text
  Output: У цьому прикладі ми використали функцію paste(), щоб обʼєднати елементи одного символьного вектора. Однак paste() можна використати для з'єднання елементів кількох символьних векторів.

- Class: cmd_question
  Output: У найпростішому випадку ми можемо з'єднати три символьні вектори, кожен довжиною 1 (тобто з'єднати три слова). Спробуй paste("Світ", "ловив", "мене", sep = " "), де аргумент `sep` вказує R, що ми хочемо розділити з'єднувані елементи одинарним пробілом.
  CorrectAnswer: paste("Світ", "ловив", "мене", sep = " ")
  AnswerTests: omnitest(correctExpr='paste("Світ", "ловив", "мене", sep = " ")')
  Hint: Введи paste("Світ", "ловив", "мене", sep = " "), щоб з'єднати слова, розділені одинарним пробілом. Між подвійними лапками в аргументі `sep` функції paste() має бути один пробіл. Можеш додати символьні вектори в paste(), щоб завершити вислів Григорія Сковороди.

- Class: cmd_question
  Output: Перейдімо до складнішого прикладу, з'єднаємо два вектори, кожен довжиною 3. Використай paste(), щоб з'єднати цілочисельний вектор 1:3 з символьним вектором c("X", "Y", "Z"). Цього разу використай sep = "", щоб не залишати пробілу між з'єднаними елементами.
  CorrectAnswer: paste(1:3, c("X", "Y", "Z"), sep = "")
  AnswerTests: any_of_exprs('paste(1:3, c("X", "Y", "Z"), sep = "")', 'paste(c(1:3), c("X", "Y", "Z"), sep = "")')
  Hint: Використай paste(1:3, c("X", "Y", "Z"), sep = ""), щоб побачити, що станеться, коли ми з'єднуємо два вектори однакової довжини за допомогою paste().

- Class: text
  Output: 'Як ти думаєш, що станеться, якщо вектори матимуть різну довжину? (Підказка: ми говорили про це в попередньому уроці.)'

- Class: cmd_question
  Output: Переробка векторів (vector recycling)! Спробуй paste(LETTERS, 1:4, sep = "-"), де LETTERS - це заздалегідь визначена змінна в R, що містить символьний вектор з усіх 26 літер англійського алфавіту.
  CorrectAnswer: paste(LETTERS, 1:4, sep = "-")
  AnswerTests: omnitest(correctExpr='paste(LETTERS, 1:4, sep = "-")')
  Hint: Набери paste(LETTERS, 1:4, sep = "-"), щоб побачити, як R переробляє вектор 1:4 аби той зрівнявся довжиною з LETTERS. Зверни увагу, що цього разу ми використовуємо як роздільник `-` замість одинарного пробілу.

- Class: text
  Output: Оскільки символьний вектор LETTERS довший за числовий вектор 1:4, R просто переробляє або повторює 1:4, поки він не відповідатиме довжині LETTERS.

- Class: text
  Output: Також варто зазначити, що функція paste() 'примушує' (coerced) числовий вектор 1:4 перетворитись на символьний.

- Class: text
  Output: Ми обговоримо примушування в іншому уроці, але по суті числа 1, 2, 3 і 4 у виході вище більше не є числами для R, а радше символами "1", "2", "3" і "4".

- Class: mult_question
  Output: Хочеш повідомити комусь про успішне завершення цього уроку?
  CorrectAnswer: NULL
  AnswerChoices: Так; Ні
  AnswerTests: notify()
  Hint: NULL
